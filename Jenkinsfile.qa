pipeline {
    agent any

    environment {
        BRANCH_NAME = 'v2.0.0'  // Rama para QA
        DOCKER_IMAGE = 'microservicio-qa'
    }

    stages {
        stage('Check if Docker Image Needs to be Built') {
      steps {
        script {
            // Obtener el hash del último commit
            def latestCommit = sh(script: 'git rev-parse HEAD', returnStdout: true).trim()

            // Obtener el commit hash de la imagen etiquetada con el último commit (no la imagen 'latest')
            def previousCommit = sh(script: """
                docker images --format '{{.Repository}}:{{.Tag}} {{.CreatedAt}}' | grep '${DOCKER_IMAGE}' | grep -v 'latest' | sort -r | head -n 1 | awk '{print \$2}'
            """, returnStdout: true).trim()

            // Si no hay ninguna imagen anterior o si la última imagen tiene el mismo commit, salimos
            if (previousCommit == latestCommit) {
                echo 'No changes detected since the last Docker image build. Skipping Docker build.'
                currentBuild.result = 'SUCCESS'
                return // Detener la ejecución del pipeline
            } else {
                echo 'Changes detected. Proceeding to build the Docker image.'
            }
        }
      }
        }

        stage('Stop and Remove Old Container') {
      steps {
        script {
          try {
            // Intentamos detener y eliminar el contenedor antiguo si existe
            sh 'docker stop --time=10 ${DOCKER_IMAGE} || true' // || true asegura que no falle si no existe
            sh 'docker rm ${DOCKER_IMAGE} || true'   // || true asegura que no falle si no existe
                    } catch (Exception e) {
            echo "No existing container found or other error: ${e}"
          }
        }
      }
        }

        stage('Checkout') {
      steps {
        git branch: "${BRANCH_NAME}", url: 'https://github.com/ignavela/test-cicd.git'
      }
        }

        stage('Build Docker Image') {
      steps {
        script {
          // Construir la imagen de Docker y etiquetar con el último commit
          def latestCommit = sh(script: 'git rev-parse HEAD', returnStdout: true).trim()
          sh "docker build . -t ${DOCKER_IMAGE}:latest -t ${DOCKER_IMAGE}:${latestCommit}"
        }
      }
        }

        stage('Deploy to QA') {
      steps {
        echo 'Desplegando la imagen en QA...'
        sh 'docker run -d -p 8082:8081 --name ${DOCKER_IMAGE} ${DOCKER_IMAGE}:latest'
      }
        }

        stage('Cleanup Old Docker Images') {
      steps {
        script {
          // Obtener el hash del último commit
          def latestCommit = sh(script: 'git rev-parse HEAD', returnStdout: true).trim()
          // Mantener las últimas 5 imágenes y eliminar las anteriores
          def images = sh(
                        script: "docker images --format '{{.Repository}}:{{.Tag}} {{.CreatedAt}}' | grep '^${DOCKER_IMAGE}' | grep -v '${latestCommit}' | sort -r | tail -n +6",
                        returnStdout: true
                    ).trim()

          if (images) {
            // Convertir la lista de imágenes a una lista de strings y eliminar
            def oldImages = images.split('\n')
            oldImages.each { image ->
              def imageName = image.split(' ')[0]
              sh "docker rmi -f ${imageName}"
            }
                    } else {
            echo 'No old images to remove.'
          }
        }
      }
        }
    }
}
