pipeline {
    agent any

    environment {
        BRANCH_NAME = 'v1.0.0'  // Rama para PROD
        DOCKER_IMAGE = 'microservicio-prod'
    }

    stages {
        stage('Checkout') {
      steps {
        git branch: "${BRANCH_NAME}", url: 'https://github.com/ignavela/test-cicd.git'
      }
        }

        stage('Check if Docker Image Needs to be Deployed') {
      steps {
        script {
          // Obtener el hash del último commit
          def latestCommit = sh(script: 'git rev-parse HEAD', returnStdout: true).trim()
          echo "Latest Commit: ${latestCommit}"
          // Obtener la imagen actualmente ejecutándose
          def runningImage = sh(
                        script: "docker inspect --format='{{.Config.Image}}' ${DOCKER_IMAGE} || echo ''",
                        returnStdout: true
                    ).trim()

          // Construir el nombre de la imagen objetivo
          def targetImage = "${DOCKER_IMAGE}:${latestCommit}"

          if (runningImage == targetImage) {
            echo "The Docker image ${targetImage} is already running. Skipping deploy."
            currentBuild.description = "Skipped build: ${latestCommit}"
            shouldProceed = false
                    } else {
            echo "The Docker image ${targetImage} is not running. Proceeding to deploy."
            shouldProceed = true
          }
        }
      }
        }

        stage('Stop and Remove Old Container') {
      steps {
        script {
          if (shouldProceed) {
            try {
              // Intentamos detener y eliminar el contenedor antiguo si existe
              sh 'docker stop --time=10 ${DOCKER_IMAGE} || true' // || true asegura que no falle si no existe
              sh 'docker rm ${DOCKER_IMAGE} || true'   // || true asegura que no falle si no existe
                    } catch (Exception e) {
              echo "No existing container found or other error: ${e}"
            }
          } else {
            echo 'Skipping stage because Docker image already exists.'
          }
        }
      }
        }

        stage('Build Docker Image') {
      steps {
        script {
          if (shouldProceed) {
            // Construir la imagen de Docker y etiquetar con el último commit
            def latestCommit = sh(script: 'git rev-parse HEAD', returnStdout: true).trim()
            sh "docker build . -t ${DOCKER_IMAGE}:latest -t ${DOCKER_IMAGE}:${latestCommit}"
                    } else {
            echo 'Skipping stage because Docker image already exists.'
          }
        }
      }
        }

        stage('Deploy to PROD') {
      steps {
        script {
          if (shouldProceed) {
            echo 'Desplegando la imagen en PROD...'
            sh 'docker run -d -p 8083:8081 --name ${DOCKER_IMAGE} ${DOCKER_IMAGE}:latest'
                    } else {
            echo 'Skipping deployment to PROD because docker image already exists.'
          }
        }
      }
        }

        stage('Cleanup Old Docker Images') {
      steps {
        script {
          if (shouldProceed) {
            // Mantener las últimas 5 imágenes y eliminar las anteriores
            def images = sh(
                            script: "docker images --format '{{.Repository}}:{{.Tag}} {{.CreatedAt}}' | grep '^${DOCKER_IMAGE}' | sort -r | tail -n +6",
                            returnStdout: true
                        ).trim()

            if (images) {
              // Convertir la lista de imágenes a una lista de strings y eliminar
              def oldImages = images.split('\n')
              oldImages.each { image ->
                def imageName = image.split(' ')[0]
                sh "docker rmi -f ${imageName}"
              }
                        } else {
              echo 'No old images to remove.'
            }
                    } else {
            echo 'Skipping cleanup of old Docker images.'
          }
        }
      }
        }
    }
}
